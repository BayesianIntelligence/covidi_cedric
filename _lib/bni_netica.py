from __future__ import division
from __future__ import print_function
from builtins import range
from past.builtins import basestring
from past.utils import old_div
from builtins import object
import ctypes, re, itertools, sys, pdb
from ctypes import *

license = ''

def setLicense(str):
	license = str

class Net:
	MESG_LEN = 256
	NOTHING_ERR = 1
	ERROR_ERR = 5
	XXX_ERR = 6
	WILDCARD_STATE = -5
	UNDEF_STATE = -3
	UNDEFINED = None # Defined later
	INFINITY = None # Defined later


# Constants
class Node:
	# Types, as specified in "Netica.h"
	CONTINUOUS_TYPE, DISCRETE_TYPE, TEXT_TYPE = list(range(1,4))
	typeName = [0,'Continuous', 'Discrete', 'Text']
	# Kinds, as specified in "Netica.h"
	NATURE_NODE, CONSTANT_NODE, DECISION_NODE, UTILITY_NODE, DISCONNECTED_NODE = list(range(1,6))
	kindName = [0, 'Nature', 'Constant', 'Decision', 'Utility', 'Disconnected']

def NYI():
	print("nyi")

def msgBuf():
	return ctypes.create_string_buffer(bytes('\000' * 4000,'ascii'))

if sys.platform == 'win32':
	try:
		g = ctypes.windll.LoadLibrary("./_lib/Netica64.dll")
	except:
		g = ctypes.windll.LoadLibrary("./_lib/Netica.dll")
elif sys.platform.startswith('linux'):
	print("Loading Netica")
	g = ctypes.cdll.LoadLibrary('./_lib/libNeticaJ.so')
else:
	print('Need platform specific library')

class c_simplechar_p(ctypes.c_char_p):
	@classmethod
	def from_param(cls, obj):
		return bytes(obj, 'ascii') if type(obj)==str else obj
	
	@classmethod
	def _check_retval_(cls, result):
		return result.value.decode('utf-8')
		
skipErrorChecks = set('ClearErrors_ns ClearError_ns ErrorCategory_ns ErrorSeverity_ns ErrorMessage_ns ErrorNumber_ns GetError_ns NewError_ns'.split(' '))

def cfunc(lib, funcName, restype, argtypes):
	func = getattr(lib, funcName)
	func.argtypes = argtypes
	func.restype = restype
	
	# I assume kwargs aren't supported, but just in case
	def checkCall(*args, **kwargs):
		#print(funcName, *args)
		res = func(*args)
		chkerr()
		return res
	
	if funcName not in skipErrorChecks:
		setattr(lib, funcName, checkCall)

# DON'T CHANGE --- Generated by makeBindings.py
checking_ns = ctypes.c_int
errseverity_ns = ctypes.c_int
errcond_ns = ctypes.c_int
eventtype_ns = ctypes.c_int
nodetype_bn = ctypes.c_int
nodekind_bn = ctypes.c_int
environ_ns = None
report_ns = None
stream_ns = None
randgen_ns = None
scripter_ns = None
net_bn = None
node_bn = None
nodelist_bn = None
caseset_cs = None
learner_bn = None
tester_bn = None
sensv_bn = None
setting_bn = None
dbmgr_cs = None
cfunc(g, "GetUndefDbl_ns", ctypes.c_double, [])
cfunc(g, "GetInfinityDbl_ns", ctypes.c_double, [])
state_bn = ctypes.c_int
prob_bn = ctypes.c_float
util_bn = ctypes.c_float
level_bn = ctypes.c_double
color_ns = ctypes.c_int
caseposn_bn = ctypes.c_long
bool_ns = ctypes.c_ubyte
sampling_bn = ctypes.c_int
learn_method_bn = ctypes.c_int
cfunc(g, "NewNeticaEnviron_ns", ctypes.POINTER(environ_ns), [c_simplechar_p, ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "InitNetica2_bn", ctypes.c_int, [ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "CloseNetica_bn", ctypes.c_int, [ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "GetNeticaVersion_bn", ctypes.c_int, [ctypes.POINTER(environ_ns), ctypes.POINTER(c_simplechar_p)])
cfunc(g, "ArgumentChecking_ns", checking_ns, [checking_ns, ctypes.POINTER(environ_ns)])
cfunc(g, "SetLanguage_ns", c_simplechar_p, [ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "LimitMemoryUsage_ns", ctypes.c_double, [ctypes.c_double, ctypes.POINTER(environ_ns)])
cfunc(g, "SetEnvironUserData_ns", None, [ctypes.POINTER(environ_ns), ctypes.c_int, ctypes.POINTER(None)])
cfunc(g, "GetEnvironUserData_ns", ctypes.POINTER(None), [ctypes.POINTER(environ_ns), ctypes.c_int])
cfunc(g, "GetError_ns", ctypes.POINTER(report_ns), [ctypes.POINTER(environ_ns), errseverity_ns, ctypes.POINTER(report_ns)])
cfunc(g, "ErrorNumber_ns", ctypes.c_int, [ctypes.POINTER(report_ns)])
cfunc(g, "ErrorMessage_ns", c_simplechar_p, [ctypes.POINTER(report_ns)])
cfunc(g, "ErrorSeverity_ns", errseverity_ns, [ctypes.POINTER(report_ns)])
cfunc(g, "ErrorCategory_ns", bool_ns, [errcond_ns, ctypes.POINTER(report_ns)])
cfunc(g, "ClearError_ns", None, [ctypes.POINTER(report_ns)])
cfunc(g, "ClearErrors_ns", None, [ctypes.POINTER(environ_ns), errseverity_ns])
cfunc(g, "NewError_ns", ctypes.POINTER(report_ns), [ctypes.POINTER(environ_ns), ctypes.c_int, errseverity_ns, c_simplechar_p])
cfunc(g, "TestFaultRecovery_ns", ctypes.c_int, [ctypes.POINTER(environ_ns), ctypes.c_int])
cfunc(g, "UserAllowed_ns", ctypes.c_int, [ctypes.POINTER(environ_ns), ctypes.c_int])
cfunc(g, "NewFileStream_ns", ctypes.POINTER(stream_ns), [c_simplechar_p, ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "NewMemoryStream_ns", ctypes.POINTER(stream_ns), [c_simplechar_p, ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "DeleteStream_ns", None, [ctypes.POINTER(stream_ns)])
cfunc(g, "SetStreamPassword_ns", None, [ctypes.POINTER(stream_ns), c_simplechar_p])
cfunc(g, "SetStreamContents_ns", None, [ctypes.POINTER(stream_ns), c_simplechar_p, ctypes.c_long, bool_ns])
cfunc(g, "GetStreamContents_ns", c_simplechar_p, [ctypes.POINTER(stream_ns), ctypes.POINTER(ctypes.c_long)])
cfunc(g, "WriteNet_bn", None, [ctypes.POINTER(net_bn), ctypes.POINTER(stream_ns)])
cfunc(g, "ReadNet_bn", ctypes.POINTER(net_bn), [ctypes.POINTER(stream_ns), ctypes.c_int])
cfunc(g, "WriteNetFindings_bn", caseposn_bn, [ctypes.POINTER(nodelist_bn), ctypes.POINTER(stream_ns), ctypes.c_long, ctypes.c_double])
cfunc(g, "ReadNetFindings2_bn", None, [ctypes.POINTER(caseposn_bn), ctypes.POINTER(stream_ns), bool_ns, ctypes.POINTER(nodelist_bn), ctypes.POINTER(ctypes.c_long), ctypes.POINTER(ctypes.c_double)])
cfunc(g, "SetCaseFileDelimChar_ns", ctypes.c_int, [ctypes.c_int, ctypes.POINTER(environ_ns)])
cfunc(g, "SetMissingDataChar_ns", ctypes.c_int, [ctypes.c_int, ctypes.POINTER(environ_ns)])
cfunc(g, "NewNet_bn", ctypes.POINTER(net_bn), [c_simplechar_p, ctypes.POINTER(environ_ns)])
cfunc(g, "CopyNet_bn", ctypes.POINTER(net_bn), [ctypes.POINTER(net_bn), c_simplechar_p, ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "DeleteNet_bn", None, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNthNet_bn", ctypes.POINTER(net_bn), [ctypes.c_int, ctypes.POINTER(environ_ns)])
cfunc(g, "NewNode_bn", ctypes.POINTER(node_bn), [c_simplechar_p, ctypes.c_int, ctypes.POINTER(net_bn)])
cfunc(g, "CopyNodes_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(nodelist_bn), ctypes.POINTER(net_bn), c_simplechar_p])
cfunc(g, "DeleteNode_bn", None, [ctypes.POINTER(node_bn)])
cfunc(g, "SetNetName_bn", None, [ctypes.POINTER(net_bn), c_simplechar_p])
cfunc(g, "SetNetTitle_bn", None, [ctypes.POINTER(net_bn), c_simplechar_p])
cfunc(g, "SetNetComment_bn", None, [ctypes.POINTER(net_bn), c_simplechar_p])
cfunc(g, "SetNetElimOrder_bn", None, [ctypes.POINTER(net_bn), ctypes.POINTER(nodelist_bn)])
cfunc(g, "SetNetAutoUpdate_bn", ctypes.c_int, [ctypes.POINTER(net_bn), ctypes.c_int])
cfunc(g, "SetNetUserField_bn", None, [ctypes.POINTER(net_bn), c_simplechar_p, ctypes.POINTER(None), ctypes.c_int, ctypes.c_int])
cfunc(g, "SetNetUserData_bn", None, [ctypes.POINTER(net_bn), ctypes.c_int, ctypes.POINTER(None)])
cfunc(g, "SetNodeName_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "SetNodeTitle_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "SetNodeComment_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "SetNodeLevels_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, ctypes.POINTER(level_bn)])
cfunc(g, "SetNodeKind_bn", None, [ctypes.POINTER(node_bn), nodekind_bn])
cfunc(g, "SetNodeStateName_bn", None, [ctypes.POINTER(node_bn), state_bn, c_simplechar_p])
cfunc(g, "SetNodeStateNames_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "SetNodeStateTitle_bn", None, [ctypes.POINTER(node_bn), state_bn, c_simplechar_p])
cfunc(g, "SetNodeStateComment_bn", None, [ctypes.POINTER(node_bn), state_bn, c_simplechar_p])
cfunc(g, "SetNodeInputName_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, c_simplechar_p])
cfunc(g, "SetNodeEquation_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "SetNodeFuncState_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn), state_bn])
cfunc(g, "SetNodeFuncReal_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn), ctypes.c_double])
cfunc(g, "SetNodeProbs_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn), ctypes.POINTER(prob_bn)])
cfunc(g, "SetNodeExperience_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn), ctypes.c_double])
cfunc(g, "DeleteNodeTables_bn", None, [ctypes.POINTER(node_bn)])
cfunc(g, "SetNodeUserField_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p, ctypes.POINTER(None), ctypes.c_int, ctypes.c_int])
cfunc(g, "SetNodeUserData_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, ctypes.POINTER(None)])
cfunc(g, "SetNodeVisPosition_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(None), ctypes.c_double, ctypes.c_double])
cfunc(g, "SetNodeVisStyle_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(None), c_simplechar_p])
cfunc(g, "GetNetName_bn", c_simplechar_p, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetTitle_bn", c_simplechar_p, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetComment_bn", c_simplechar_p, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetNodes2_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(net_bn), c_simplechar_p])
cfunc(g, "GetNodeNamed_bn", ctypes.POINTER(node_bn), [c_simplechar_p, ctypes.POINTER(net_bn)])
cfunc(g, "GetNetFileName_bn", c_simplechar_p, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetAutoUpdate_bn", ctypes.c_int, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetElimOrder_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetUserField_bn", c_simplechar_p, [ctypes.POINTER(net_bn), c_simplechar_p, ctypes.POINTER(ctypes.c_int), ctypes.c_int])
cfunc(g, "GetNetNthUserField_bn", None, [ctypes.POINTER(net_bn), ctypes.c_int, ctypes.POINTER(c_simplechar_p), ctypes.POINTER(c_simplechar_p), ctypes.POINTER(ctypes.c_int), ctypes.c_int])
cfunc(g, "GetNetUserData_bn", ctypes.POINTER(None), [ctypes.POINTER(net_bn), ctypes.c_int])
cfunc(g, "GetNodeNet_bn", ctypes.POINTER(net_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeName_bn", c_simplechar_p, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeTitle_bn", c_simplechar_p, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeComment_bn", c_simplechar_p, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeType_bn", nodetype_bn, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeKind_bn", nodekind_bn, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeNumberStates_bn", ctypes.c_int, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeLevels_bn", ctypes.POINTER(level_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeStateName_bn", c_simplechar_p, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "GetNodeStateTitle_bn", c_simplechar_p, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "GetNodeStateComment_bn", c_simplechar_p, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "GetStateNamed_bn", state_bn, [c_simplechar_p, ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeParents_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeChildren_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeInputName_bn", c_simplechar_p, [ctypes.POINTER(node_bn), ctypes.c_int])
cfunc(g, "GetInputNamed_bn", ctypes.c_int, [c_simplechar_p, ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeEquation_bn", c_simplechar_p, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeFuncState_bn", state_bn, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn)])
cfunc(g, "GetNodeFuncReal_bn", ctypes.c_double, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn)])
cfunc(g, "GetNodeProbs_bn", ctypes.POINTER(prob_bn), [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn)])
cfunc(g, "GetNodeExperience_bn", ctypes.c_double, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn)])
cfunc(g, "HasNodeTable_bn", bool_ns, [ctypes.POINTER(node_bn), ctypes.POINTER(bool_ns)])
cfunc(g, "IsNodeDeterministic_bn", bool_ns, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeUserField_bn", c_simplechar_p, [ctypes.POINTER(node_bn), c_simplechar_p, ctypes.POINTER(ctypes.c_int), ctypes.c_int])
cfunc(g, "GetNodeNthUserField_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, ctypes.POINTER(c_simplechar_p), ctypes.POINTER(c_simplechar_p), ctypes.POINTER(ctypes.c_int), ctypes.c_int])
cfunc(g, "GetNodeUserData_bn", ctypes.POINTER(None), [ctypes.POINTER(node_bn), ctypes.c_int])
cfunc(g, "GetNodeVisPosition_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(None), ctypes.POINTER(ctypes.c_double), ctypes.POINTER(ctypes.c_double)])
cfunc(g, "GetNodeVisStyle_bn", c_simplechar_p, [ctypes.POINTER(node_bn), ctypes.POINTER(None)])
cfunc(g, "AddLink_bn", ctypes.c_int, [ctypes.POINTER(node_bn), ctypes.POINTER(node_bn)])
cfunc(g, "DeleteLink_bn", None, [ctypes.c_int, ctypes.POINTER(node_bn)])
cfunc(g, "SwitchNodeParent_bn", None, [ctypes.c_int, ctypes.POINTER(node_bn), ctypes.POINTER(node_bn)])
cfunc(g, "IsNodeRelated_bn", bool_ns, [ctypes.POINTER(node_bn), c_simplechar_p, ctypes.POINTER(node_bn)])
cfunc(g, "GetRelatedNodes_bn", None, [ctypes.POINTER(nodelist_bn), c_simplechar_p, ctypes.POINTER(node_bn)])
cfunc(g, "GetRelatedNodesMult_bn", None, [ctypes.POINTER(nodelist_bn), c_simplechar_p, ctypes.POINTER(nodelist_bn)])
cfunc(g, "NewNodeList2_bn", ctypes.POINTER(nodelist_bn), [ctypes.c_int, ctypes.POINTER(net_bn)])
cfunc(g, "DeleteNodeList_bn", None, [ctypes.POINTER(nodelist_bn)])
cfunc(g, "ClearNodeList_bn", None, [ctypes.POINTER(nodelist_bn)])
cfunc(g, "LengthNodeList_bn", ctypes.c_int, [ctypes.POINTER(nodelist_bn)])
cfunc(g, "AddNodeToList_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "RemoveNthNode_bn", ctypes.POINTER(node_bn), [ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "NthNode_bn", ctypes.POINTER(node_bn), [ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "SetNthNode_bn", None, [ctypes.POINTER(nodelist_bn), ctypes.c_int, ctypes.POINTER(node_bn)])
cfunc(g, "IndexOfNodeInList_bn", ctypes.c_int, [ctypes.POINTER(node_bn), ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "DupNodeList_bn", ctypes.POINTER(nodelist_bn), [ctypes.POINTER(nodelist_bn)])
cfunc(g, "ReviseCPTsByFindings_bn", None, [ctypes.POINTER(nodelist_bn), ctypes.c_int, ctypes.c_double])
cfunc(g, "ReviseCPTsByCaseFile_bn", None, [ctypes.POINTER(stream_ns), ctypes.POINTER(nodelist_bn), ctypes.c_int, ctypes.c_double])
cfunc(g, "FadeCPTable_bn", None, [ctypes.POINTER(node_bn), ctypes.c_double])
cfunc(g, "AddNodeStates_bn", None, [ctypes.POINTER(node_bn), state_bn, c_simplechar_p, ctypes.c_int, ctypes.c_double])
cfunc(g, "RemoveNodeState_bn", None, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "ReorderNodeStates_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(state_bn)])
cfunc(g, "EquationToTable_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, bool_ns, bool_ns])
cfunc(g, "ReverseLink_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(node_bn)])
cfunc(g, "AbsorbNodes_bn", None, [ctypes.POINTER(nodelist_bn)])
cfunc(g, "EnterFinding_bn", None, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "EnterFindingNot_bn", None, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "EnterNodeValue_bn", None, [ctypes.POINTER(node_bn), ctypes.c_double])
cfunc(g, "EnterNodeLikelihood_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(prob_bn)])
cfunc(g, "EnterNodeCalibration_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(prob_bn)])
cfunc(g, "EnterIntervalFinding_bn", None, [ctypes.POINTER(node_bn), ctypes.c_double, ctypes.c_double])
cfunc(g, "EnterGaussianFinding_bn", None, [ctypes.POINTER(node_bn), ctypes.c_double, ctypes.c_double])
cfunc(g, "GetNodeFinding_bn", state_bn, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeValueEntered_bn", ctypes.c_double, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeLikelihood_bn", ctypes.POINTER(prob_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "RetractNodeFindings_bn", None, [ctypes.POINTER(node_bn)])
cfunc(g, "RetractNetFindings_bn", None, [ctypes.POINTER(net_bn)])
cfunc(g, "CalcNodeState_bn", state_bn, [ctypes.POINTER(node_bn)])
cfunc(g, "CalcNodeValue_bn", ctypes.c_double, [ctypes.POINTER(node_bn)])
cfunc(g, "CompileNet_bn", None, [ctypes.POINTER(net_bn)])
cfunc(g, "UncompileNet_bn", None, [ctypes.POINTER(net_bn)])
cfunc(g, "SizeCompiledNet_bn", ctypes.c_double, [ctypes.POINTER(net_bn), ctypes.c_int])
cfunc(g, "IsBeliefUpdated_bn", bool_ns, [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeBeliefs_bn", ctypes.POINTER(prob_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "GetNodeExpectedValue_bn", ctypes.c_double, [ctypes.POINTER(node_bn), ctypes.POINTER(ctypes.c_double), ctypes.POINTER(ctypes.c_double), ctypes.POINTER(ctypes.c_double)])
cfunc(g, "GetNodeExpectedUtils_bn", ctypes.POINTER(util_bn), [ctypes.POINTER(node_bn)])
cfunc(g, "FindingsProbability_bn", ctypes.c_double, [ctypes.POINTER(net_bn)])
cfunc(g, "GetNetExpectedUtility_bn", util_bn, [ctypes.POINTER(net_bn)])
cfunc(g, "JointProbability_bn", ctypes.c_double, [ctypes.POINTER(nodelist_bn), ctypes.POINTER(state_bn)])
cfunc(g, "MostProbableConfig_bn", None, [ctypes.POINTER(nodelist_bn), ctypes.POINTER(state_bn), ctypes.c_int])
cfunc(g, "NewSensvToFinding_bn", ctypes.POINTER(sensv_bn), [ctypes.POINTER(node_bn), ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "DeleteSensvToFinding_bn", None, [ctypes.POINTER(sensv_bn)])
cfunc(g, "GetMutualInfo_bn", ctypes.c_double, [ctypes.POINTER(sensv_bn), ctypes.POINTER(node_bn)])
cfunc(g, "GetVarianceOfReal_bn", ctypes.c_double, [ctypes.POINTER(sensv_bn), ctypes.POINTER(node_bn)])
cfunc(g, "GenerateRandomCase_bn", ctypes.c_int, [ctypes.POINTER(nodelist_bn), sampling_bn, ctypes.c_double, ctypes.POINTER(randgen_ns)])
cfunc(g, "AddNodeToNodeset_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "RemoveNodeFromNodeset_bn", None, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "IsNodeInNodeset_bn", bool_ns, [ctypes.POINTER(node_bn), c_simplechar_p])
cfunc(g, "GetAllNodesets_bn", c_simplechar_p, [ctypes.POINTER(net_bn), bool_ns, ctypes.POINTER(None)])
cfunc(g, "SetNodesetColor_bn", color_ns, [c_simplechar_p, color_ns, ctypes.POINTER(net_bn), ctypes.POINTER(None)])
cfunc(g, "ReorderNodesets_bn", None, [ctypes.POINTER(net_bn), c_simplechar_p, ctypes.POINTER(None)])
cfunc(g, "NewCaseset_cs", ctypes.POINTER(caseset_cs), [c_simplechar_p, ctypes.POINTER(environ_ns)])
cfunc(g, "DeleteCaseset_cs", None, [ctypes.POINTER(caseset_cs)])
cfunc(g, "AddFileToCaseset_cs", None, [ctypes.POINTER(caseset_cs), ctypes.POINTER(stream_ns), ctypes.c_double, c_simplechar_p])
cfunc(g, "WriteCaseset_cs", None, [ctypes.POINTER(caseset_cs), ctypes.POINTER(stream_ns), c_simplechar_p])
cfunc(g, "NewDBManager_cs", ctypes.POINTER(dbmgr_cs), [c_simplechar_p, c_simplechar_p, ctypes.POINTER(environ_ns)])
cfunc(g, "DeleteDBManager_cs", None, [ctypes.POINTER(dbmgr_cs)])
cfunc(g, "ExecuteDBSql_cs", None, [ctypes.POINTER(dbmgr_cs), c_simplechar_p, c_simplechar_p])
cfunc(g, "InsertFindingsIntoDB_bn", None, [ctypes.POINTER(dbmgr_cs), ctypes.POINTER(nodelist_bn), c_simplechar_p, c_simplechar_p, c_simplechar_p])
cfunc(g, "AddDBCasesToCaseset_cs", None, [ctypes.POINTER(caseset_cs), ctypes.POINTER(dbmgr_cs), ctypes.c_double, ctypes.POINTER(nodelist_bn), c_simplechar_p, c_simplechar_p, c_simplechar_p, c_simplechar_p])
cfunc(g, "AddNodesFromDB_bn", None, [ctypes.POINTER(dbmgr_cs), ctypes.POINTER(net_bn), c_simplechar_p, c_simplechar_p, c_simplechar_p, c_simplechar_p])
cfunc(g, "NewLearner_bn", ctypes.POINTER(learner_bn), [learn_method_bn, c_simplechar_p, ctypes.POINTER(environ_ns)])
cfunc(g, "DeleteLearner_bn", None, [ctypes.POINTER(learner_bn)])
cfunc(g, "SetLearnerMaxIters_bn", ctypes.c_int, [ctypes.POINTER(learner_bn), ctypes.c_int])
cfunc(g, "SetLearnerMaxTol_bn", ctypes.c_double, [ctypes.POINTER(learner_bn), ctypes.c_double])
cfunc(g, "LearnCPTs_bn", None, [ctypes.POINTER(learner_bn), ctypes.POINTER(nodelist_bn), ctypes.POINTER(caseset_cs), ctypes.c_double])
cfunc(g, "NewNetTester_bn", ctypes.POINTER(tester_bn), [ctypes.POINTER(nodelist_bn), ctypes.POINTER(nodelist_bn), ctypes.c_int])
cfunc(g, "DeleteNetTester_bn", None, [ctypes.POINTER(tester_bn)])
cfunc(g, "TestWithCaseset_bn", None, [ctypes.POINTER(tester_bn), ctypes.POINTER(caseset_cs)])
cfunc(g, "GetTestErrorRate_bn", ctypes.c_double, [ctypes.POINTER(tester_bn), ctypes.POINTER(node_bn)])
cfunc(g, "GetTestLogLoss_bn", ctypes.c_double, [ctypes.POINTER(tester_bn), ctypes.POINTER(node_bn)])
cfunc(g, "GetTestQuadraticLoss_bn", ctypes.c_double, [ctypes.POINTER(tester_bn), ctypes.POINTER(node_bn)])
cfunc(g, "GetTestConfusion_bn", ctypes.c_double, [ctypes.POINTER(tester_bn), ctypes.POINTER(node_bn), state_bn, state_bn])
cfunc(g, "SetNetNumUndos_bn", None, [ctypes.POINTER(net_bn), ctypes.c_int, ctypes.c_double, c_simplechar_p])
cfunc(g, "UndoNetLastOper_bn", ctypes.c_int, [ctypes.POINTER(net_bn), ctypes.c_double])
cfunc(g, "RedoNetOper_bn", ctypes.c_int, [ctypes.POINTER(net_bn), ctypes.c_double])
cfunc(g, "GetNodeLabel_bn", ctypes.c_int, [ctypes.POINTER(node_bn), ctypes.POINTER(ctypes.c_ushort), ctypes.c_int, c_simplechar_p])
cfunc(g, "GetNodeStateLabel_bn", ctypes.c_int, [ctypes.POINTER(node_bn), state_bn, ctypes.POINTER(ctypes.c_ushort), ctypes.c_int, c_simplechar_p])
cfunc(g, "CreateCustomReport_bn", c_simplechar_p, [ctypes.POINTER(net_bn), ctypes.POINTER(nodelist_bn), c_simplechar_p, c_simplechar_p])
cfunc(g, "ControlConcurrency_ns", c_simplechar_p, [ctypes.POINTER(environ_ns), c_simplechar_p, c_simplechar_p])
cfunc(g, "ControlNetCaching_bn", c_simplechar_p, [ctypes.POINTER(net_bn), c_simplechar_p, c_simplechar_p, ctypes.POINTER(nodelist_bn)])
cfunc(g, "ExpandNet_bn", ctypes.POINTER(net_bn), [ctypes.POINTER(net_bn), ctypes.c_int, ctypes.c_double, ctypes.c_double, c_simplechar_p])
cfunc(g, "SetNodeInputDelay_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, ctypes.c_int, c_simplechar_p])
cfunc(g, "SetNodePersistance_bn", None, [ctypes.POINTER(node_bn), ctypes.c_int, c_simplechar_p])
cfunc(g, "GetNodeAtTime_bn", ctypes.POINTER(node_bn), [ctypes.POINTER(net_bn), c_simplechar_p, ctypes.POINTER(ctypes.c_double)])
cfunc(g, "NewRandomGenerator_ns", ctypes.POINTER(randgen_ns), [c_simplechar_p, ctypes.POINTER(environ_ns), c_simplechar_p])
cfunc(g, "DeleteRandomGen_ns", None, [ctypes.POINTER(randgen_ns)])
cfunc(g, "GetRandomGenState_ns", c_simplechar_p, [ctypes.POINTER(randgen_ns), c_simplechar_p])
cfunc(g, "GenerateRandomNumbers_ns", ctypes.c_double, [ctypes.POINTER(randgen_ns), ctypes.POINTER(ctypes.c_double), ctypes.c_int, c_simplechar_p])
cfunc(g, "SetNetRandomGen_bn", None, [ctypes.POINTER(net_bn), ctypes.POINTER(randgen_ns), bool_ns])
cfunc(g, "EnterAction_bn", None, [ctypes.POINTER(node_bn), state_bn])
cfunc(g, "EnterActionValue_bn", None, [ctypes.POINTER(node_bn), ctypes.c_double])
cfunc(g, "EnterActionRandomized_bn", None, [ctypes.POINTER(node_bn), ctypes.POINTER(prob_bn)])
cfunc(g, "CleanupThreadEnding_ns", None, [ctypes.POINTER(environ_ns)])
cfunc(g, "NthProb_bn", ctypes.c_double, [ctypes.POINTER(prob_bn), state_bn])
cfunc(g, "NthLevel_bn", ctypes.c_double, [ctypes.POINTER(level_bn), state_bn])
cfunc(g, "GetChars_ns", ctypes.c_int, [c_simplechar_p, ctypes.c_int, ctypes.POINTER(ctypes.c_ushort), ctypes.c_int])
cfunc(g, "NthChar_ns", ctypes.c_int, [c_simplechar_p, ctypes.c_int])
cfunc(g, "SetNthState_bn", None, [ctypes.POINTER(state_bn), ctypes.c_int, state_bn])
cfunc(g, "OptimizeDecisions_bn", None, [ctypes.POINTER(nodelist_bn)])
cfunc(g, "NewNodeList_bn", ctypes.POINTER(nodelist_bn), [ctypes.c_int, ctypes.POINTER(environ_ns)])

# Errors, and error checking
# Note: internally, need to call chkerr() after every operation
ErrorCheckingOn = False
def NewError( number, severity, message):
	errorReport = c_void_p(g.NewError_ns(env, number, severity, byref(message)))
	return errorReport
def ClearError( error):
	g.ClearError_ns(error)
def ClearErrors( severity = Net.ERROR_ERR):
	g.ClearErrors_ns(env, severity)
def GetError( severity, after = None):
	if ErrorCheckingOn:
		res = g.GetError_ns(env, severity, after)
		if res: return c_void_p(res)
		else:   return None
def ErrorMessage( error):
	return g.ErrorMessage_ns(error)
def chkerr():
	if GetError(Net.ERROR_ERR):
		exceptionMsg = "PyNetica: Error in " + ErrorMessage(GetError(Net.ERROR_ERR))
		#res, mesg = CloseNetica()
		#print(mesg)
		# Try clearing the error:
		ClearErrors()
		raise BNIError(exceptionMsg)


env = g.NewNeticaEnviron_ns(license, None, None)
g.LimitMemoryUsage_ns(70000000, env)
mesg = msgBuf()
g.InitNetica2_bn(env, mesg)
ErrorCheckingOn = True

class BNIError(Exception):
	def __init__(self, msg):
		self.msg = msg
	def __str__(self):
		return self.msg

class Net(Net):
	UNDEFINED = g.GetUndefDbl_ns()
	INFINITY = g.GetInfinityDbl_ns()

	def __init__(self, fn = "", autoUpdate = True):
		self.eNet = None # A pointer to the network as represented by the engine
		self._autoUpdate = True
	
		if fn:
			s = g.NewFileStream_ns(fn, env, None)
			self.eNet = g.ReadNet_bn(s, 0)
			chkerr()
		else:
			self.eNet = c_void_p(g.NewNet_bn('untitled', env))
			chkerr()
		self.autoUpdate(autoUpdate)
	
	def __del__(self):
		g.DeleteNet_bn(self.eNet)
	
	# autoUpdate can be turned off for performance. You then need
	# to manually use 'update' after changes and before reading beliefs.
	def autoUpdate(self, autoUpdate = None):
		if autoUpdate is not None:
			g.SetNetAutoUpdate_bn(self.eNet, autoUpdate)
			self._autoUpdate = True
			self.compile()
		else:
			return self._autoUpdate

	# Trigger update if not auto-updating
	def update(self):
		if not self._autoUpdate:
			# Just set and unset autoupdate to get a single belief update
			self.autoUpdate(True)
			self.autoUpdate(False)
		
	def name(self, _name = None):
		if _name is None:
			return g.GetNetName_bn(self.eNet)
		else:
			g.SetNetName_bn(self.eNet, _name)
			
		return self
			
	def title(self, _title = None):
		if _title is None:
			return g.GetNetTitle_bn(self.eNet)
		else:
			g.SetNetTitle_bn(self.eNet, _title)
			
		return self
	
	def write(self, fn):
		s = g.NewFileStream_ns(fn, env, None)
		g.WriteNet_bn(self.eNet, s)
		
	def node(self, name):
		nodePtr = g.GetNodeNamed_bn(name, self.eNet)
		chkerr()
		return Node(eNodePtr = nodePtr, net = self) if nodePtr is not None else None

	def addNode(self, name, states = None, levels = None, nodeType = None):
		return Node(self, name, states = states, levels = levels, nodeType = nodeType)
	
	def compile(self):
		g.CompileNet_bn(self.eNet)
		chkerr()
		return self
	
	def retractFindings(self):
		g.RetractNetFindings_bn(self.eNet)
		chkerr()
		
	def nodes(self):
		nodeList = g.GetNetNodes2_bn(self.eNet, None)
		numNodes = g.LengthNodeList_bn(nodeList)

		return [Node(self,eNodePtr=g.NthNode_bn(nodeList, i)) for i in range(numNodes)]
		
	def findingsProbability(self):
		return g.FindingsProbability_bn(self.eNet)

	# Not sure these belong here
	@classmethod
	def numberCombinations(cls, nodes):
		total = 1

		for i in range(len(nodes)):
			total *= nodes[i].numberStates()

		return total

	# This function works for discrete nodes only, of course
	# nodeStates should be an array the size of len(nodes)
	@classmethod
	def nextCombination(cls, nodeStates, nodes, skip = []):
		# Flip skip array (which also makes it a dict)
		fs = {}
		for i,v in enumerate(skip): fs[v] = skip[i]
		skip = fs
		
		numNodes = len(nodeStates)
		for i in range(numNodes-1,-1,-1):
			if i in skip: continue
			nodeStates[i] += 1
			if nodeStates[i] >= nodes[i].numberStates():
				# Set the i^th node state to 0 and continue to next node
				nodeStates[i] = 0
			else:
				# More combinations to come
				return True
		# All node states have rolled back round to 0
		return False


class Node(Node):
	def __init__(self, net = None, name = None, states = None, levels = None, nodeType = None, eNodePtr = None):
		self.net = net
		self.eId = eNodePtr # The node pointer in Netica (for the given net)
		
		# If all states are actually floats, assume they are levels
		if states is not None:
			def isFloat(x): return isinstance(x,float) or isinstance(x,int)
			if sum(not isFloat(s) for s in states) == 0:
				levels = states
				states = []
		
		if self.eId is None:
			numStates = 0
			if nodeType == Node.CONTINUOUS_TYPE or levels is not None:
				# Can have 0 states, or multiple states
				pass
			elif nodeType is None or nodeType == Node.DISCRETE_TYPE:
				if not states:
					states = ["state0", "state1"]
				numStates = len(states)
				
			if name is not None:
				if not self.checkValidName(name):
					raise BNIError("Node name "+repr(name)+" is not valid. Must have " +
						"first character as letter/underscore, "+
						"other characters as letter/number/underscore and max. 30 characters")
				self.eId = g.NewNode_bn(name, numStates, self.net.eNet)
				chkerr()

				# XXX: Set node type to be done
				if nodeType: pass

			if states:  self.renameStates(states)
			if levels:  self.levels(levels)
		
		chkerr()
	
	def checkValidName(self, name):
		# Netica convention: first character is letter/underscore,
		# other characters are letter/number/underscore
		# Max 30 characters
		if re.match(r'[a-zA-Z_][a-zA-Z0-9_]{,29}', name):
			return True
		else:
			return False
			
	#def name(self):
	#	return g.GetNodeName_bn(self.eId)
		
	#OW: added set node name functionality 10/9/20
	def name(self, _name = None):
		if _name is None:
			return g.GetNodeName_bn(self.eId)
		else:
			g.SetNodeName_bn(self.eId, _name)
			
		return self
					
	#OW: added set node title functionality 7/9/20
	def title(self, _title = None):
		if _title is None:
			return g.GetNodeTitle_bn(self.eId)
		else:
			g.SetNodeTitle_bn(self.eId, _title)
		return self
		
	def type(self, _type = None):
		if _type is None:
			return g.GetNodeType_bn(self.eId)
		else:
			nyi()
			# g.SetNodeType_bn(self.eId, _type)
			# SM (2020-09-07): SetNodeType doesn't exist. Not sure if there's another way to add it
		
		return self
	
	def levels(self, _levels = None):
		if _levels is None:
			numList = g.GetNodeLevels_bn(self.eId)
			#pdb.set_trace()
			levels = [numList[i] for i in range(self.numberStates()+1)]
			
			return levels
		else:
			n = len(_levels)
			numList = (c_double*n)(*_levels)
		
			g.SetNodeLevels_bn(self.eId, n-1, numList)
			chkerr()
		
		return self
		
	def kind(self, _kind = None):
		if _kind is None:
			return g.GetNodeKind_bn(self.eId)
		else:
			g.SetNodeKind_bn(self.eId, _kind)
		
		return self
		
	def parents(self):
		nodeList = g.GetNodeParents_bn(self.eId)
		numParents = g.LengthNodeList_bn(nodeList)

		parents = []
		for i in range(numParents):
			parents.append(Node(self.net, eNodePtr=g.NthNode_bn(nodeList, i)))
		return parents

	#OW added 12/09/20
	def children(self):
		nodeList = g.GetNodeChildren_bn(self.eId)
		numChildren = g.LengthNodeList_bn(nodeList)

		children = []
		for i in range(numChildren):
			children.append(Node(self.net, eNodePtr=g.NthNode_bn(nodeList, i)))
		return children
		
	def addParents(self, parents):
		"""
		Each element of parents can be an existing node name or node.
		"""
		for parent in parents:
			# Make sure each parent is a Node object
			if isinstance(parent, basestring):
				parent = self.net.node(parent)
			g.AddLink_bn(parent.eId, self.eId)
			chkerr()
		
		# Allow the call chain to continue
		return self
		
	def addChildren(self, children):
		"""
		Each element of children can be an existing node name or node.
		"""
		for child in children:
			# Make sure each child is a Node object
			if isinstance(child, basestring):
				child = self.net.node(child)
			g.AddLink_bn(self.eId, child.eId)
			chkerr()

		# Allow the call chain to continue
		return self
	
	def removeParents(self, parents):
		myParents = self.parents()
		toRemove = []
		for parent in parents:
			# Make sure each parent is a Node object
			if isinstance(parent, basestring):
				parent = self.net.node(parent)
			# Find index (will change each time)
			for i,myParent in enumerate(myParents):
				if myParent.name() == parent.name():
					toRemove.append(i)
					break
		
		for i in sorted(toRemove, reverse=True):
			g.DeleteLink_bn(i, self.eId)
		
		return self
	
	def removeChildren(self, children):
		for child in children:
			# Make sure each child is a Node object
			if isinstance(child, basestring):
				child = self.net.node(child)
			# Find index in child's parents
			for i,childParent in enumerate(child.parents()):
				if childParent.name() == self.name():
					g.DeleteLink_bn(i, child.eId)
					break
		
		return self
	
	def state(self, name = None, value = None):
		if value is not None:
			levels = g.GetNodeLevels_bn(self.eId)
			for i,val in enumerate(levels):
				#OW: <= changed to < 6/9/20
				if value < val:
					#OW: i changed to i-1 6/9/20
					name = i-1
					break
			
					
		# If int (assumed if not basestring), then just get state
		if not isinstance(name,basestring):
			return State(self,name)
		
		stateI = g.GetStateNamed_bn(name, self.eId)
		if stateI == Net.UNDEF_STATE:
			return None
		
		return State(self, stateI)
		
	def states(self):
		return [State(self,i) for i in range(self.numberStates())]
	
	def stateByTitle(self, title):
		for state in self.states():
			if state.title() == title:
				return state
		
		return None
		
	def hasState(self, name):
		if self.state(name) is None:
			return False
		
		return True
	
	def addState(self, name):
		g.AddNodeStates_bn(self.eId, -1, name, 1, ctypes.c_double(-1.0))
		
		# Chain
		return self
	
	def renameState(self, name, newName):
		g.SetNodeStateName_bn(self.eId, self.state(name).stateNum, newName)
		chkerr()
		
		# Chain
		return self
		
	def renameStates(self, newNames):
		g.SetNodeStateNames_bn(self.eId, ",".join(newNames))
		chkerr()
		
		# Chain
		return self
	
	def reorderStates(self, ordering):
		# Netica does this the opposite of what I would have thought, and GeNIe agrees, so reverse these
		newOrdering = [0]*len(ordering)
		for i,v in enumerate(ordering):
			v = self.state(v).stateNum
			newOrdering[v] = i
		ordering = newOrdering
		
		g.ReorderNodeStates_bn(self.eId, (c_int*len(ordering))(*ordering))
		
		return self
		
	def setExperience(self, parentStates, experience):
		# It's not clear to me GeNIe supports this
		NYI()
	
	def numberStates(self):
		return g.GetNodeNumberStates_bn(self.eId)
		
	def retractFindings(self):
		g.RetractNodeFindings_bn(self.eId)
		chkerr()
	
	def likelihoods(self, likelihoodVector = None):
		if likelihoodVector is None:
			lk = g.GetNodeLikelihood_bn(self.eId)
			return [lk[i] for i in range(self.numberStates())]
		else:
			chkerr()
			from struct import pack
			n = len(likelihoodVector)
			fp = (ctypes.c_float*n)(*likelihoodVector)
			g.EnterNodeLikelihood_bn(self.eId, fp)
			chkerr()
	
	def finding(self, state = None, value = None):
		stateOb = None
		if value is not None:
			#OW: cast value to float 6/9/20
			stateOb = self.state(value = float(value))
		else:
			stateOb = self.state(state)
		stateOb.setTrueFinding()
		
		return self
		
	def findingByTitle(self, stateTitle):
		state = self.stateByTitle(stateTitle)
		if state is None:
			state = self.state(stateTitle)
		state.setTrueFinding()
		
		return self
		
	def expectedUtils(self):
		NYI()
	def beliefs(self):
		if not self.net._autoUpdate:
			self.net.update()
		
		p = g.GetNodeBeliefs_bn(self.eId)
		chkerr()
		return [p[i] for i in range(self.numberStates())]
		
	def expectedValue(self):
		if not self.net._autoUpdate:
			self.net.update()
		
		ev = g.GetNodeExpectedValue_bn(self.eId, None, None, None)
		chkerr()
		
		return ev
		
	def probs(self, parentStates):
		NYI()

	def stateNames(self):
		return [g.GetNodeStateName_bn(self.eId, i) for i in range(self.numberStates())]
	
	def position(self, x = None, y = None):
		if x is None:
			# Possible Netica 5.04 issue that you have to try to set pos on something
			# before you get it for anything
			if not hasattr(self.net, '_posFix'):
				self.net._posFix = True
				# Add temp node, set its position, then remove it
				#node = self.net.addNode('___kldfom234')
				#node.position(0,0).remove()
			x = ctypes.c_double()
			y = ctypes.c_double()
			g.GetNodeVisPosition_bn(self.eId, None, ctypes.byref(x), ctypes.byref(y))
			return [x.value, y.value]
		else:
			g.SetNodeVisPosition_bn(self.eId, None, ctypes.c_double(x), ctypes.c_double(y))
			
			# Chain
			return self

	def cpt1d(self, newCpt = None):
		numEntries = self.numberStates()*self.net.numberCombinations(self.parents())

		if newCpt is None:
			if not g.HasNodeTable_bn(self.eId, None):
				return None
		
			pt = g.GetNodeProbs_bn(self.eId, None)
			chkerr()
			
			return [pt[i] for i in range(numEntries)]

		else:
			numStates = self.numberStates()
			
			rows = int(numEntries/numStates)
			
			# Normalisation
			for r in range(rows):
				r *= numStates
				totalRow = sum(newCpt[r:r+numStates])
				if totalRow:
					for i in range(r, r+numStates):
						newCpt[i] = newCpt[i]/totalRow
			
			nc = (ctypes.c_float*len(newCpt))(*newCpt)
			
			g.SetNodeProbs_bn(self.eId, None, nc)
			chkerr()
		
		# Chain
		return self
	
	def cpt(self, newCpt = None):
		if newCpt is None:
			cpt1d = self.cpt1d()
			numStates = self.numberStates()

			def chunks(l, n):
				return [l[i:i+n] for i in range(0, len(l), n)]

			cpt = chunks(cpt1d, numStates)

			return cpt
		else:
			self.cpt1d(list(itertools.chain(*newCpt)))
		
		# Chain
		return self
	
	def setUniform(self):
		numEntries = self.numberStates()*self.net.numberCombinations(self.parents())
		self.cpt1d([float(1)/self.numberStates() for i in range(numEntries)])
		
		# Chain
		return self
	
	def remove(self):
		g.DeleteNode_bn(self.eId)
		chkerr()
		
		return self

class State(object):
	def __init__(self, node = None, stateNum = None):
		self.node = node
		self.stateNum = stateNum
	
	def name(self, _name = None):
		#rint(self.node.name(), _name)
		if _name is None:
			return g.GetNodeStateName_bn(self.node.eId, self.stateNum)
		else:
			g.SetNodeStateName_bn(self.node.eId, self.stateNum, _name)
		
			# Chain
			return self

	def title(self, _title = None):
		if _title is None:
			return g.GetNodeStateTitle_bn(self.node.eId, self.stateNum)
		else:
			g.SetNodeStateTitle_bn(self.node.eId, self.stateNum, _title)
		
			# Chain
			return self

	def setTrueFinding(self):
		g.RetractNodeFindings_bn(self.node.eId)
		g.EnterFinding_bn(self.node.eId, self.stateNum)
		chkerr()
